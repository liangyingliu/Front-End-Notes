###  字面量和变量和常量的区别？

**字面量**其实就是一个值，它所代表的含义就是它字面的意思

  **变量**

- 变量可以用“存储”字面量
- 并且变量中存储的字面量可以随意的修改
-  通过变量可以对字面量进行描述，并且变量比较方便修改
- 变量储存的是一个内存地址，而不是一个值

**常量**只能赋值一次，重复赋值会报错，使用const声明常量，除了常规的常量外，有一些对象类型的数据我们也会声明为常量

### 输入和输出

输出和输入也可理解为人和计算机的交互，用户通过键盘、鼠标等向计算机输入信息，计算机处理后再展示结果给用户，这便是一次输入和输出的过程。

举例说明：如按键盘上的方向键，向上/下键可以滚动页面，按向上/下键这个动作叫作输入，页面发生了滚动了这便叫输出。

#### 输出

JavaScript 可以接收用户的输入，然后再将输入的结果输出：

`alert()`、`document.wirte()`

以数字为例，向 `alert()` 或 `document.write()`输入任意数字，他都会以弹窗形式展示（输出）给用户。

####  输入

向 `prompt()` 输入任意内容会以弹窗形式出现在浏览器中，一般提示用户输入一些内容。



### 数据类型

#### 数值（Number）

- 在JS中所有的整数和浮点数都是Number类型
- JS中的数值并不是无限大的，当数值超过一定范围后会显示近似值
- Infinity 是一个特殊的数值表示无穷
- 所以在JS中进行一些精度比较高的运算时要十分注意
- NaN 也是一个特殊的数值，表示非法的数值

#####  大整数（BigInt）

- \- 大整数用来表示一些比较大的整数
- \- 大整数使用n结尾，它可以表示的数字范围是无限大

```
    let score = 100 // 正整数
    let price = 12.345 // 小数
    let temperature = -40 // 负数

    document.write(typeof score) // 结果为 number
    document.write(typeof price) // 结果为 number
    document.write(typeof temperature) // 结果为 number
```

#### 字符串（String）

**在JS中使用单引号或双引号来表示字符串**

   - 转义字符 \
       \" --> "
       \' --> '
       \\ --> \\
       \t --> 制表符
       \n --> 换行
   - 模板字符串
       - 使用反单引号` 来表示模板字符串
       - 模板字符串中可以嵌入变量
   - 使用typeof检查一个字符串时会返回 "string"

#### 布尔值（Boolean）

- \- 布尔值主要用来进行逻辑判断
- \- 布尔值只有两个true 和 false
- \- 使用typeof检查一个布尔值时会返回 "boolean"

####  空值 （Null）

   - 空值用来表示空对象
   - 空值只有一个 null
   - 使用typeof检查一个空值时会返回"object"
   - 使用typeof无法检查空值（检查空值并不准确）

#### 未定义（Undefined）

- \- 当声明一个变量而没有赋值时，它的值就是Undefined
- \- Undefined类型的值只有一个就是 undefined
- \- 使用typeof检查一个Undefined类型的值时，会返回 "undefined"

#### 符号（Symbol）

- \- 用来创建一个唯一的标识   

- \- 使用typeof检查符号时会返回 "symbol"

  ```
  
         let c = Symbol() // 调用Symbol()创建了一个符号
  
         console.log(typeof c)//Symbol()
  ```

  

###  **typeof 运算符**

​          \- typeof用来检查不同的值的类型

​          \- 它会根据不同的值返回不同的结果

### 数据类型转换

[^数据类型转换就是根据一个值去创建一个新的值]: 

####  转换为字符串

#####   1.调用toString()方法将其他类型转换为字符串

- 调用xxx的yyy方法--> xxx.yyy()

- 由于null和undefined中没有toString() 所以对这两个东西调用toString()时会报错

  ```
  let a = 10
  a=a.toString()//根据原有的数字10创建一个字符串"10"赋值给a
  console.log(typeof a,a)// string "10"
  ```

  

#####   2.调用String()函数将其他类型转换为字符串

- 调用xxx函数--> xxx()

- 原理：

  - 对于拥有toString()方法的值调用String()函数时，实际上就是在调用toString()方法

  - 对于null，则直接转换为字符串"null"

  - 对于undefined，直接转换为字符串"undefined"

```
let a = 10
a=String(a)//根据原有的数字10创建一个字符串"10"赋值给a
console.log(typeof a,a)// string "10"
```

#### 转换为数值

##### 1.使用Number()函数来将其他类型转换为数值

 **转换的情况：**

字符串：

​              \- 如果字符串是一个合法的数字，则会自动转换为对应的数字

​              \- 如果字符串不是合法数字，则转换为NaN

​              \- 如果字符串是空串或纯空格的字符串，则转换为0

布尔值：

​			  \- true转换为1，false转换为0

null ：转换为 0

undefined ：转换为 NaN

**专门用来将字符串转换为数值的两个方法：** 

 **parseInt()** —— 将一个字符串转换为一个整数

​            \- 解析时，会自左向右读取一个字符串，直到读取到字符串中所有的有效的整数

​            \- 也可以使用parseInt()来对一个数字进行取整

```
let b ='123px'
b=Number(b)
console.log(b)//NaN
b=parseInt(b)
console.log(b)//123
```

**parseFloat()** —— 将一个字符串转换为浮点数 

​           \- 解析时，会自左向右读取一个字符串，直到读取到字符串中所有的有效的小数

```
let b ='123.456aaa'
b=parseFloat(b)
console.log(b)//123.456
```

#### 转换为布尔值

#####  1.使用Boolean()函数来将其他类型转换为布尔值

**转换的情况：**

​			 数字：

​                \- 0 和 NaN 转换为false

​                \- 其余是true

​             字符串：

​               \- 空串 转换为 false

​                \- 其余是true

​             null和undefined 都转换为 false

​             对象：对象会转换为true

*所有表示空性的没有的错误的值都会转换为false：0、NaN、空串、null、undefined、false*

### 运算符（操作符）

**运算符可以用来对一个或多个操作数（值）进行运算**

    - **算术运算符：**
        
        - '+'加法运算符
        - '-'减法运算符
        - '*'乘法运算符
        - '/ '除法运算符
        - '** '幂运算
        - '%' 模运算，两个数相除取余数
    
        **注意：**
        
        算术运算时，除了字符串的加法，其他运算的操作数是非数值时，都会转换为数值然后再运算

​       当任意一个值和字符串做加法运算时，它会先将其他值转换为字符串， 然后再做拼串的操作，可以通过为任意类型 + 一个空串的形式来将其转换为字符串(字符串的隐式转换)

- **赋值运算符：** 赋值运算符用来将一个值赋值给一个变量
  - '='将符号右侧的值赋值给左侧的变量
  - '??='空赋值,只有当变量的值为null或undefined时才会对变量进行赋值
  - '+='  a += n 等价于 a = a + n
  - '-='   a -= n 等价于 a = a - n
  - '*='  a *= n 等价于 a = a * n
  - '/='   a /= n 等价于 a = a / n
  - '%='  a %= n 等价于 a = a % n
  - '**='  

- **一元的±:**

  - \'+' 正号:不会改变数值的符号
  - '-' 负号:可以对数值进行符号位取反

  **注意：** 

  当我们对非数值类型进行正负运算时，会先将其转换为数值然后再运算（数值的隐式转换）

- **自增运算符：**

  - ++ 使用后会使得原来的变量立刻增加1

  - 自增分为前自增(++a)和后自增(a++)

  - 无论是++a还是a++都会使原变量立刻增加1

  - 不同的是++a和a++所返回的值不同

  - a++ 是自增前的值 旧值

  - ++a 是自增后的值 新值

- **自减运算符：**

  - 使用后会使得原来的变量立刻减小1

  - 自减分为前自减(--a)和后自减(a--)

  - 无论是--a还是a--都会使原变量立刻减少1

  - 不同的是--a和a--的值不同

  -  --a 是新值

  - a-- 是旧值

- **逻辑运算符：**

  -  **! 逻辑非**

    -  ! 可以用来对一个值进行非运算

    -  它可以对一个布尔值进行取反操作

    - true --> false

    - false --> true

    - 如果对一个非布尔值进行取反，它会先将其转换为布尔值然后再取反

    - 可以利用这个特点将其他类型转换为布尔值（布尔值的隐式转换）

  -  **&& 逻辑与**
    - 可以对两个值进行与运算
    - 当&&左右都为true时，则返回true，否则返回false
    - 与运算是短路的与，如果第一个值为false，则不看第二个值（一假全假）

  -  **|| 逻辑或**
    -  可以对两个值进行或运算
    - 当||左右有true时，则返回true，否则返回false
    - 或运算也是短路的或，如果第一个值为true，则不看第二个值（一真全真）

- **关系运算符**:关系运算符用来检查两个值之间的关系是否成立，成立返回true，不成立返回false
  - '>'用来检查左值是否大于右值
  - '\>='用来检查左值是否大于或等于右值
  - '<'用来检查左值是否小于右值
  - '<='用来检查左值是否小于或等于右值

- **相等运算符**:用来比较两个值是否相等

  - '=='
    - 使用相等运算符比较两个不同类型的值时，会将其转换为相同的类型（通常转换为数值）然后再比较类型转换后值相同会返回true
    - null和undefined进行相等比较时会返回true
    - NaN不和任何值相等，包括它自身

  - '==='
    - 全等运算符，用来比较两个值是否全等
    - 它不会进行自动的类型转换，如果两个值的类型不同直接返回false
    - null和undefined进行全等比较时会返回false

  - '!='
    - 不等，用来检查两个值是否不相等
    - 会自动的进行类型转换

  - !==
    - 不全等，比较两个值是否不全等
    - 不和自动的类型转换

- **条件运算符:**条件表达式 ? 表达式1 : 表达式2

  -  **执行顺序：**

    -  条件运算符在执行时，会先对条件表达式进行求值判断， 如果结果为true，则执行表达式1 如果结果为false，则执行表达式2

      ```
      let a = 100
      let b = 200
      let max = a > b ? a : b
      console.log(max)//200
      ```

- **运算符的优先级**:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence网站查询

### 类型转换

- **转换为字符串**

  - 显式转换String()

  - 隐式转换 \+ ""

- **转换为数值**

  - 显式转换 Number()

  - 隐式转换  +

- **转换为布尔值**

  - 显式转换Boolean()

  - 隐式转换 !！（给任何一个形式取两次反来转化为布尔值）

### 代码块

-  使用 {} 来创建代码块，代码块可以用来对代码进行分组，同一个代码中的代码，就是同一组代码，一个代码块中的代码要么都执行要么都不执行
- **let 和 var**

  - 在JS中，使用let声明的变量具有块作用域，在代码块中声明的变量无法在代码块的外部访问
- 使用var声明的变量，不具有块作用域

### 流程控制语句（判断）

#### **if语句**

​        **\- 语法：**

​          if(条件表达式){

​            语句...

​          }

```
  if(a > 10){
            alert('a比10大')
        }
```

- **执行流程**

  - if语句在执行会先对if后的条件表达式进行求值判断，

  - 如果结果为true，则执行if后的语句
  - 如果为false则不执行

####  if-else语句

​      **\- 语法：**

​        if(条件表达式){

​          语句...

​        }else{

​          语句...

​        }

- **\- 执行流程：**
  -  if-else执行时，先对条件表达式进行求值判断，
  - 如果结果为true 则执行if后的语句
  - 如果结果为false 则执行else后的语句

####  if-else if-else语句：

**语法：**

​        if(条件表达式){

​          语句...

​        }else if(条件表达式){

​          语句...

​        }else if(条件表达式){

​          语句...

​        }else{

​          语句...

​        }

-    **\- 执行流程：**

  - if-else if-else语句，会自上向下依次对if后的条件表达式进行求值判断，

  - 如果条件表达式结果为true，则执行当前if后的语句，执行完毕语句结束

  - 如果条件表达式结果为false，则继续向下判断，直到找到true为止

  - 如果所有的条件表达式都是false，则执行else后的语句

​        **注意：**

 if-else if-else语句中只会有一个代码块被执行，一旦有执行的代码块，下边的条件都不会在继续判断了，所以一定要注意，条件的编写顺序

####  switch语句

**\- 语法：**

​            switch(表达式){

​              case 表达式:

​                代码...

​                break

​              case 表达式:

​                代码...

​                break

​              default:

​                代码...

​                break

​            }

 **\- 执行的流程**

​            switch语句在执行时，会依次将switch后的表达式和case后的表达式进行全等比较

​              如果比较结果为true，则自当前case处开始执行代码

​              如果比较结果为false，则继续比较其他case后的表达式，直到找到true为止

​              如果所有的比较都是false，则执行default后的语句

**\- 注意：**

​            当比较结果为true时，会从当前case处开始执行代码

​              也就是说case是代码执行的起始位置

​            这就意味着只要是当前case后的代码，都会执行

​            可以使用break来避免执行其他的case

 **\- 总结**

​            switch语句和if语句的功能是重复，switch能做的事if也能做，反之亦然。

​              它们最大的不同在于，switch在多个全等判断时，结构比较清晰

### 流程控制语句（循环）

####     循环语句

- 通过循环语句可以使指定的代码反复执行
- JS中一共有三种循环语句
  - while语句
  - do-while语句
  - for语句

#### while语句

 **\- 语法：**

​            while(条件表达式){

​              语句...

​            }

**\- 执行流程：**

- while语句在执行时，会先对条件表达式进行判断，
- 如果结果为true，则执行循环体，执行完毕，继续判断
- 如果为true，则再次执行循环体，执行完毕，继续判断，如此重复
- 直到条件表达式结果为false时，循环结束
- 当一个循环的条件表达式恒为true时，这个循环就是一个死循环，会一直执行（慎用）

**注意：**

​      通常编写一个循环，要有三个要件

​        1.初始化表达式（初始化变量）

​        2.条件表达式（设置循环运行的条件）

​        3.更新表单式（修改初始化变量）

####  do-while循环

**\- 语法：**

​          do{

​            语句...

​          }while(条件表达式)

**\- 执行顺序：**

​          do-while语句在执行时，会先执行do后的循环体，

​            执行完毕后，会对while后的条件表达式进行判断

​            如果为false，则循环终止

​            如果为true，则继续执行循环体，以此类推

**和while的区别：**

​            while语句是先判断再执行

​            do-while语句是先执行再判断

**实质的区别：**

​              do-while语句可以确保循环至少执行一次

#### for循环

-  \- for循环和while没有本质区别，都是用来反复执行代码
- \- 不同点就是语法结构，for循环更加清晰

**\- 语法：**

​          for(①初始化表达式; ②条件表达式; ④更新表达式){

​            ③语句...

​          }

**\- 执行流程：**

​          ① 执行初始化表达式，初始化变量

​          ② 执行条件表达式，判断循环是否执行（true执行，false终止）

​          ③ 判断结果为true，则执行循环体

​          ④ 执行更新表达式，对初始化变量进行修改

​          ⑤ 重复②，知道判断为false为止

**注意：**

- 初始化表达式，在循环的整个的生命周期中只会执行1次
- for循环中的三个表达式都可以省略
- 使用let在for循环的()中声明的变量是局部变量，只能在for循环内部访问
- 使用var在for循环的()中声明的变量可以在for循环的外部访问
- 创建死循环的方式：while(1){}，for(;;){}

### break和continue

#### break

- break用来终止switch和循环语句
- break执行后，当前的switch或循环会立刻停止
- break会终止离他最近的循环

#### continue

- continue用来跳过当次循环

###  对象（object）

#### 对象的基本属性

**对象**是JS中的一种复合数据类型，它相当于一个容器，在对象中可以存储各种不同类型数据

- 对象中可以存储多个各种类型的数据，对象中存储的数据，我们称为属性

- 向对象中添加属性：对象.属性名 = 属性值

- 读取对象中的属性
  - 对象.属性名
  - 如果读取的是一个对象中没有的属性不会报错而是返回undefined

**对象的属性名**

- 通常属性名就是一个字符串，所以属性名可以是任何值，没有什么特殊要求但是如果你的属性名太特殊了，不能直接使用，需要使用[]来设置，虽然如此，但是我们还是强烈建议属性名也按照标识符的规范命名。

- 也可以使用符号（symbol）作为属性名，来添加属性获取这种属性时，也必须使用symbol，使用symbol添加的属性，通常是那些不希望被外界访问的属性

- 使用[]去操作属性时，可以使用变量

  ```
  obj.if = "哈哈" // 不建议
  obj.let = "嘻嘻"// 不建议
  obj["1231312@#@!#!#!"] = "呵呵"// 不建议
  
  let mySymbol = Symbol()// 使用symbol作为属性名
  obj[mySymbol] = "通过symbol添加的属性"
  console.log(obj[mySymbol])//取出Symbol储存的值
  ```

  

**对象的属性值**

- 对象的属性值可以是任意的数据类型，也可以是一个对象

**注意:**

使用typeof检查一个对象时，会返回object

####  **对象字面量**

- 可以直接使用{} 来创建对象

- 使用{}所创建的对象，可以直接向对象中添加属性

  ```
  语法：
            {
  
              属性名:属性值,
  
              [属性名]:属性值,
  
            }
  
  
          let mySymbol = Symbol()
  
          let obj2 = {
              name:"孙悟空", 
              age:18,
              ["gender"]:"男",
              [mySymbol]:"特殊的属性",
              hello:{
                  a:1,
                  b:true
              }
          }
  
          console.log(obj)
          console.log(obj2)
          
  ```

  ​    

#### in 运算符

-  用来检查对象中是否含有某个属性
-  语法 属性名 in obj
- 如果有返回true，没有返回false

```
console.log("name" in obj)
```

####  枚举属性

枚举属性，指将对象中的所有的属性全部获取

 **for-in语句**

**语法：**

​        for(let propName in 对象){

​          语句...

​        }

- for-in的循环体会执行多次，有几个属性就会执行几次，每次执行时，都会将一个属性名赋值给我们所定义的变量

**注意：**并不是所有的属性都可以枚举，比如 使用符号添加的属性

```
    let obj = {
            name:'孙悟空',
            age:18,
            gender:"男",
            address:"花果山",
            [Symbol()]:"测试的属性" // 符号添加的属性是不能枚举
        }

        for(let propName in obj){
            console.log(propName, obj[propName])
        }
        //name 孙悟空
        //age 18
        //gender 男
        //address 花果山
```

#### 可变类型

- 原始值都属于不可变类型，一旦创建就无法修改

  ```
  let a = 10 //声明一个a等于10
  a = 12 //重新给a赋值
  ```

- 在内存中不会创建重复的原始值

```
        let a = 10 
        let b = 10
        a = 12 // 当我们为一个变量重新赋值时，绝对不会影响其他变量
```

 **对象属于可变类型**

- 对象创建完成后，可以任意的添加删除修改对象中的属性

**注意：**

- 当对两个对象进行相等或全等比较时，比较的是对象的内存地址
- 如果有两个变量同时指向一个对象，通过一个变量修改对象时，对另外一个变量也会产生影响

**修改对象**

-  修改对象时，如果有其他变量指向该对象
- 则所有指向该对象的变量都会受到影响

 **修改变量**

- 修改变量时，只会影响当前的变量

**注意：**

- 在使用变量存储对象时，很容易因为改变变量指向的对象，提高代码的复杂度，所以通常情况下，声明存储对象的变量时会使用const

- const只是禁止变量被重新赋值，对对象的修改没有任何影响

**方法（method）**

- 当一个对象的属性指向一个函数，那么我们就称这个函数是该对象的方法

- 调用函数就称为调用对象的方法

### 函数

#### 函数（Function）

- 函数也是一个对象
- 它具有其他对象所有的功能
- 函数中可以存储代码，且可以在需要时调用这些代码

​      **语法：**

​        function 函数名(){

​          语句...

​        }

**调用函数：**

-  调用函数就是执行函数中存储的代码

- 语法：函数对象()

- 使用typeof检查函数对象时会返回function

#### 函数的定义方式：

**1.函数声明**

​          function 函数名(){

​            语句...

​          }

**2.函数表达式**

​          const 变量 = function(){

​            语句...

​          }

**3.箭头函数**

​          () => {

​            语句...

​          }

#### 参数

#####             **形式参数**

- 在定义函数时，可以在函数中指定数量不等的形式参数（形参）
- 在函数中定义形参，就相当于在函数内部声明了对应的变量但是没有赋值

#####             实际参数

- 在调用函数时，可以在函数的()传递数量不等的实参
- 实参会赋值给其对应的形参

- 参数：
  - 1.如果实参和形参数量相同，则对应的实参赋值给对应的形参
  - 2.如果实参多余形参，则多余的实参不会使用
  - 3.如果形参多余实参，则多余的形参为undefined

**参数的类型**

JS中不会检查参数的类型，可以传递任何类型的值作为参数

- **函数声明**

  ​                    function 函数名([参数]){

  ​                        语句...

  ​                    }

- **函数表达式**

  ​                const 变量 = function([参数]){

  ​                    语句...

  ​                }

-  **箭头函数**

  ​                ([参数]) => {

  ​                    语句...

  ​                }

  - 当箭头函数中只有一个参数时，可以省略()

**注意：**

- 定义参数时，可以为参数指定默认值，默认值，会在没有对应实参时生效

- 函数每次调用，都会重新创建默认值

  ```
   // 函数每次调用，都会重新创建默认值
          function fn2(a = {name:"沙和尚"}){
              console.log("a =", a)
              a.name = "唐僧"
              console.log("a =", a)
          }
  
          fn2() // 沙和尚 唐僧
          fn2() // 沙和尚 唐僧 or 唐僧 唐僧
  ```

  

#### 函数的返回值

在函数中，可以通过return关键字来指定函数的返回值，返回值就是函数的执行结果，函数调用完毕返回值便会作为结果返回

```
          function sum(a, b) {
                // console.log(a + b)
                // 计算完成后，将计算的结果返回而不是直接打印
                return a + b
            }
```

- 任何值都可以作为返回值使用（包括对象和函数之类）
- 如果return后不跟任何值，则相当于返回undefined
-  如果不写return，那么函数的返回值依然是undefined
- return一执行函数立即结束

**箭头函数的返回值**

箭头函数的返回值可以直接写在箭头后，

```
onst sum = (a, b) => a + b
```

如果直接在箭头后设置对象字面量为返回值时，对象字面量必须使用()括起来

```
       const fn = () => ({name:"孙悟空"})
```

#### 作用域（scope）

作用域指的是一个变量的可见区域

##### 全局作用域 

- 全局作用域在网页运行时创建，在网页关闭时消耗
- 所有直接编写到script标签中的代码都位于全局作用域中
-  全局作用域中的变量是全局变量，可以在任意位置访问

##### 局部作用域（块级作用域）

- 块作用域是一种局部作用域
- 块作用域在代码块执行时创建，代码块执行完毕它就销毁
-  在块作用域中声明的变量是局部变量，只能在块内部访问，外部无法访问

#####  函数作用域

- 函数作用域也是一种局部作用域
- 函数作用域在函数调用时产生，调用结束后销毁
- 函数每次调用都会产生一个全新的函数作用域
- 在函数中定义的变量是局部变量，只能在函数内部访问，外部无法访问

#### 作用域链

​        **当我们使用一个变量时，**

​          JS解释器会优先在当前作用域中寻找变量，

​            如果找到了则直接使用

​            如果没找到，则去上一层作用域中寻找，找到了则使用

​            如果没找到，则继续去上一层寻找，以此类推

​            如果一直到全局作用域都没找到，则报错 xxx is not defined

#### Window对象

- 在浏览器中，浏览器为我们提供了一个window对象，可以直接访问
- window对象代表的是浏览器窗口，通过该对象可以对浏览器窗口进行各种操作，除此之外window对象还负责存储JS中的内置对象和浏览器的宿主对象
- window对象的属性可以通过window对象访问，也可以直接访问
- 函数就可以认为是window对象的方法

#####  var 用来声明变量，作用和let相同，但是var不具有块作用域

-  在全局中使用var声明的变量，都会作为window对象的属性保存
- 使用function声明的函数，都会作为window的方法保存
- 使用let声明的变量不会存储在window对象中，而存在一个秘密的小地方（无法访问）
- var虽然没有块作用域，但有函数作用域

**注意：**在局部作用域中，如果没有使用var或let声明变量，则变量会自动成为window对象的属性 也就是全局变量

#### 变量提升

**变量的提升**

​          \- 使用var声明的变量，它会在所有代码执行前被声明，所以我们可以在变量声明前就访问变量

```
            console.log(b)

            var b = 10//undefined
            
            执行过程把 var b 提升上去
            var b
            
            console.log(b)
            
            b=10
```

**函数的提升**

​          \- 使用函数声明创建的函数，会在其他代码执行前被创建，所以我们可以在函数声明前调用函数

```

            fn()

            function fn(){
                alert("我是fn函数~")
            }
            
            执行过程把 function fn() 提升上去
            
           function fn(){
                alert("我是fn函数~")
            }
            
            fn()
```

**注意：**let声明的变量实际也会提升，但是在赋值之前解释器禁止对该变量的访问

**变量提升是为了提前分配内存空间，为了判断变量赋值空间大小，避免内存分配过大造成不必要的资源浪费**

#### debugger

//debugger // 在代码中打了一个断点

```
<script>

            console.log(a) // 2
            var a = 1
            console.log(a) // 1
            
            debugger 
            
            function a() {
                alert(2)
            }
            console.log(a) // 1

           
        </script>
```

#### 立即执行函数

- 立即是一个匿名的函数，并它只会调用一次
- 可以利用IIFE来创建一个一次性的函数作用域，避免变量冲突的问题

```
   (function(){
            let a = 10
            console.log(111)
        }());
```

#### this

- 函数在执行时，JS解析器每次都会传递进一个隐含的参数，这个参数就叫做 this
- this会指向一个对象
-  this所指向的对象会根据函数调用方式的不同而不同
  - 1.以函数形式调用时，this指向的是window
  - 2.以方法的形式调用时，this指向的是调用方法的对象

- 通过this可以在方法中引用调用方法的对象

- 箭头函数没有自己的this，它的this有外层作用域决定
- 箭头函数的this和它的调用方式无关

**箭头函数的例子：**

- 无参箭头函数：() => 返回值

- 一个参数的：a => 返回值

- 多个参数的：(a, b) => 返回值

- 只有一个语句的函数：() => 返回值

- 只返回一个对象的函数：() => ({...})

- 有多行语句的函数：() => {

​          ....   

​          return 返回值

​        }****

#### 严格模式

**JS运行代码的模式有两种：**

**正常模式**

- 默认情况下代码都运行在正常模式中，在正常模式，语法检查并不严格，它的原则是：能不报错的地方尽量不报错

- 这种处理方式导致代码的运行性能较差

**严格模式**

在严格模式下，语法检查变得严格

- 1.禁止一些语法
- 2.更容易报错
- 3.提升了性能

在开发中，应该尽量使用严格模式， 这样可以将一些隐藏的问题消灭在萌芽阶段，同时也能提升代码的运行性能

```
 "use strict" // 全局的严格模式
 
         let a = 10

        // console.log(a)

        function fn(){
            "use strict" // 函数的严格的模式
        }
```

### 面向对象

#### **面向对象编程（OOP）**

- 程序是干嘛的？
  - 程序就是对现实世界的抽象（照片就是对人的抽象）
- 对象是干嘛的？
  - 一个事物抽象到程序中后就变成了对象
  - 在程序的世界中，一切皆对象
- 面向对象的编程
  - 面向对象的编程指，程序中的所有操作都是通过对象来完成
  - 做任何事情之前都需要先找到它的对象，然后通过对象来完成各种操作

**例如**

**心仪的女人：王老五**

- 一个事物通常由两部分组成：数据和功能
-  一个对象由两部分组成：属性和方法
- 事物的数据到了对象中，体现为属性
- 事物的功能到了对象中，体现为方法

数据：

​          姓名

​          年龄

​          身高

​          体重

功能：

​          睡

​          吃  

```
       const five = {
            // 添加属性
            name:"王老五",
            age:48,
            height:180,
            weight:100,

            // 添加方法
            sleep(){
                console.log(this.name + "睡觉了~")
            },

            eat(){
                console.log(this.name + "吃饭了~")
            }
       }

```

#### 类

#####         使用Object创建对象的问题：

- 无法区分出不同类型的对象

- 不方便批量创建对象

 **在JS中可以通过类（class）来解决这个问题：**

-  类是对象模板，可以将对象中的属性和方法直接定义在类中定义后，就可以直接通过类来创建对象
- 通过同一个类创建的对象，我们称为同类对象，可以使用instanceof来检查一个对象是否是由某个类创建，如果某个对象是由某个类所创建，则我们称该对象是这个类的实例

**语法：**

​          class 类名 {} // 类名要使用大驼峰命名

​          const 类名 = class {}  

**通过类创建对象**

​          new 类()

类是创建对象的模板，要创建第一件事就是定义类

**添加类的属性：**

```
       class Person{
            /* 
                类的代码块，默认就是严格模式，
                类的代码块是用来设置对象的属性的，不是什么代码都能写
            */
           name = "孙悟空" // Person的实例属性name p1.name
           age = 18       // 实例属性只能通过实例访问 p1.age

           static test = "test静态属性" // 使用static声明的属性，是静态属性（类属性） Person.test
           static hh = "静态属性"   // 静态属性只能通过类去访问 Person.hh
        }
        
        const p1 = new Person()
        const p2 = new Person()

        console.log(p1)
        console.log(p2)
        
        console.log(Person.test)
        console.log(Person.hh)
```

**添加类的方法**

```
class Person{

            name = "孙悟空"

            // sayHello = function(){

            // } // 添加方法的一种方式

            sayHello(){
                console.log('大家好，我是' + this.name)
            } // 添加方法（实例方法） 实例方法中this就是当前实例

            static test(){
                console.log("我是静态方法", this)
            } // 静态方法（类方法） 通过类来调用 静态方法中this指向的是当前类

        }

        const p1 = new Person()

        // console.log(p1)

        Person.test()

        p1.sayHello()
```

##### 构造函数

```
        class Person{
      
            // 在类中可以添加一个特殊的方法constructor
            // 该方法我们称为构造函数（构造方法）
            // 构造函数会在我们调用类创建对象时执行
            constructor(name, age, gender){
                // console.log("构造函数执行了~", name, age, gender)
                // 可以在构造函数中，为实例属性进行赋值
                // 在构造函数中，this表示当前所创建的对象
                this.name = name
                this.age = age
                this.gender = gender

            }

        }

        const p1 = new Person("孙悟空", 18, "男")
        const p2 = new Person("猪八戒", 28, "男")
        const p3 = new Person("沙和尚", 38, "男")

        console.log(p1)
        console.log(p2)
        console.log(p3)

```

#####  面向对象的特点：封装、继承和多态

**1.封装**-安全性

- 对象就是一个用来存储不同属性的容器

- 对象不仅存储属性，还要负责数据的安全

- 直接添加到对象中的属性，并不安全，因为它们可以被任意的修改

- 如何确保数据的安全：

  - 1.私有化数据
    - 将需要保护的数据设置为私有，只能在类内部使用

  - 2.提供setter和getter方法来开放对数据的操作
    - \- 属性设置私有，通过getter（get）、 setter（set）方法操作属性带来的好处
      - \1. 可以控制属性的读写权限
      - \2. 可以在方法中对属性的值进行验证

- 封装主要用来保证数据的安全

- 实现封装的方式：

  - 属性私有化 加#

  - 通过getter和setter方法来操作属性（可以在里面书写逻辑/如：添加if判断）

    ​            get 属性名(){

    ​              return this.#属性

    ​            }

    ​            set 属性名(参数){

    ​              this.#属性 = 参数

    ​            }

**2.多态**-灵活性

​            定义一个函数，这个函数将接收一个对象作为参数，他可以输出hello并打印对象的name属性

- **多态**
  - 在JS中不会检查参数的类型，所以这就意味着任何数据都可以作为参数传递
  - 要调用某个函数，无需指定的类型，只要对象满足某些条件即可
  - 如果一个东西走路像鸭子，叫起来像鸭子，那么它就是鸭子
  - 多态为我们提供了灵活性

**3.继承**-扩展性

- 可以通过extends关键来完成继承
- 当一个类继承另一个类时，就相当于将另一个类中的代码复制到了当前类中（简单理解）
-  继承发生时，被继承的类称为 父类（超类），继承的类称为 子类
- 通过继承可以减少重复的代码，并且可以在不修改一个类的前提对其进行扩展

```
        class Animal{
            constructor(name){
                this.name = name
            }

            sayHello(){
                console.log("动物在叫~")
            }
        }

        class Dog extends Animal{
            
        }

        class Cat extends Animal{
            
        }

        class Snake extends Animal{

        }

        const dog = new Dog("旺财")
        const cat = new Cat("汤姆")

        dog.sayHello()
        cat.sayHello()
        console.log(dog)
        console.log(cat)
```

```
        /* 
            继承
                - 通过继承可以在不修改一个类的情况下对其进行扩展
                - OCP 开闭原则
                    - 程序应该对修改关闭，对扩展开放

        */

        class Animal{
            constructor(name){
                this.name = name
            }

            sayHello(){
                console.log("动物在叫~")
            }
        }

        class Dog extends Animal{

            // 在子类中，可以通过创建同名方法来重写父类的方法
            sayHello(){
                console.log("汪汪汪")
            }
            
        }

        class Cat extends Animal{

            // 重写构造函数
            constructor(name, age){
                // 重写构造函数时，构造函数的第一行代码必须为super()
                super(name) // 调用父类的构造函数

                this.age = age

            }
            
            sayHello(){

                // 调用一下父类的sayHello
                super.sayHello() // 在方法中可以使用super来引用父类的方法

                console.log("喵喵喵")
            }
        }

        
        const dog = new Dog("旺财")
        const cat = new Cat("汤姆", 3)

        dog.sayHello()
        cat.sayHello()
        console.log(dog)
```

#### 对象的结构

##### 1.对象自身

- 直接通过对象所添加的属性，位于对象自身中
- 类中通过 x = y 的形式添加的属性，位于对象自身中

##### 2.原型对象（prototype）

- 对象中还有一些内容，会存储到其他的对象里（原型对象）
- 在对象中会有一个属性用来存储原型对象，这个属性叫做__proto__
- 原型对象也负责为对象存储属性，
  - 当我们访问对象中的属性时，会优先访问对象自身的属性，
  - 对象自身不包含该属性时，才会去原型对象中寻找
- 会添加到原型对象中的情况：
  - 在类中通过xxx(){}方式添加的方法，位于原型中
  - 主动向原型中添加的属性或方法

**访问一个对象的原型对象**

```
对象.__proto__//不建议、容易使用=被赋值
Object.getPrototypeOf(对象)
```

**原型对象中的数据：**

- 对象中的数据（属性、方法等）
- constructor （对象的构造函数）

**注意：**

原型对象也有原型，这样就构成了一条原型链，根据对象的复杂程度不同，原型链的长度也不同

p对象的原型链：p对象 --> 原型 --> 原型 --> null

 obj对象的原型链：obj对象 --> 原型 --> null

**原型链：**

- 读取对象属性时，会优先对象自身属性，
  -  如果对象中有，则使用，没有则去对象的原型中寻找
  - 如果原型中有，则使用，没有则去原型的原型中寻找
  -  直到找到Object对象的原型（Object的原型没有原型（为null））
  -  如果依然没有找到，则返回undefined
- 作用域链，是找变量的链，找不到会报错
- 原型链，是找属性的链，找不到会返回undefined

**所有的同类型对象它们的原型对象都是同一个，也就意味着，同类型对象的原型链是一样的**

**原型的作用：**

- 原型就相当于是一个公共的区域，可以被所有该类实例访问，可以将该类实例中，所有的公共属性（方法）统一存储到原型中，这样我们只需要创建一个属性，即可被所有实例访问
- JS中继承就是通过原型来实现的,当继承时，子类的原型就是一个父类的实例
- 在对象中有些值是对象独有的，像属性（name，age，gender）每个对象都应该有自己值，但是有些值对于每个对象来说都是一样的，像各种方法，对于一样的值没必要重复的创建

**修改原型**

 大部分情况下，我们是不需要修改原型对象

**注意：**千万不要通过类的实例去修改原型

-  通过一个对象影响所有同类对象，这么做不合适
- 修改原型先得创建实例，麻烦
- 危险

 处理通过__proto__能访问对象的原型外，还可以通过类的prototype属性，来访问实例的原型

**修改原型时，最好通过通过类去修改**

- 好处：

  - 一修改就是修改所有实例的原型

  - 无需创建实例即可完成对类的修改

- 原则：
  - 原型尽量不要手动改
  - 要改也不要通过实例对象去改
  - 通过 类.prototype 属性去修改
  - 最好不要直接给prototype去赋值

#### instanceof和hasOwn

**instanceof 用来检查一个对象是否是一个类的实例**

- instanceof检查的是对象的原型链上是否有该类实例只要原型链上有该类实例，就会返回true

- Object是所有对象的原型，所以任何和对象和Object进行instanceof运算都会返回true

**in**

- 使用in运算符检查属性时，无论属性在对象自身还是在原型中，都会返回true

**对象.hasOwnProperty(属性名) (不推荐使用)**

`hasOwnProperty` 方法会返回一个布尔值，表示对象**自身属性**中是否具有对应的值（原型链上的属性不会读取）

**Object.hasOwn(对象, 属性名)** 

用来检查一个对象的自身是否含有某个属性

#### 旧类（早期创建class类）

- 一个函数如果直接调用 xxx() 那么这个函数就是一个普通函数

  ```
  function Person(){
  
  }
  ```

-  一个函数如果通过new调用 new xxx() 那么这个函数就是一个构造函数

  ```
  function Person(){
  
  }
  
  const p = new Person()
  
  ```

#### new运算符

**new运算符是创建对象时要使用的运算符,**

- 使用new时，到底发生了哪些事情：

​        https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new

- 当使用new去调用一个函数时，这个函数将会作为构造函数调用,使用new调用函数时，将会发生这些事：
  - 创建一个普通的JS对象（Object对象 {}）, 为了方便，称其为新对象
  - 将构造函数的prototype属性设置为新对象的原型
  - 使用实参来执行构造函数，并且将新对象设置为函数中的this
  - 如果构造函数返回的是一个非原始值，则该值会作为new运算的返回值返回（千万不要这么做）,如果构造函数的返回值是一个原始值或者没有指定返回值，则新的对象将会作为返回值返回,通常不会为构造函数指定返回值

####  对象的分类

**内建对象**

- 由ES标准所定义的对象
- 比如 Object Function String Number ....

**宿主对象**

- 由浏览器提供的对象
- BOM、DOM

**自定义对象**

- 由开发人员自己创建的对象

### 数组（Array）

#### 数组（Array）

- 数组也是一种复合数据类型，在数组可以存储多个不同类型的数据

- 数组中存储的是有序的数据，数组中的每个数据都有一个唯一的索引，可以通过索引来操作获取数据

- 数组中存储的数据叫做元素

- 索引（index）是一组大于0的整数

- **创建数组** 通过Array()来创建数组，也可以通过[]来创建数组

-  向数组中添加元素

  - 语法：

    ​              数组[索引] = 元素

- 读取数组中的元素

  - 语法：

    数组[索引]

    ​              \- 如果读取了一个不存在的元素，不好报错而是返回undefined

- **length**

  - 获取数组的长度
  - 获取的实际值就是数组的最大索引 + 1
  - 向数组最后添加元素：数组[数组.length] = 元素
  - length是可以修改的


#### 遍历数组

遍历数组简单理解，就是获取到数组中的每一个元素

**for-of语句可以用来遍历可迭代对象**

- **语法：**

​          for(变量 of 可迭代的对象){

​            语句...

​          }

- **执行流程：**

​          for-of的循环体会执行多次，数组中有几个元素就会执行几次，每次执行时都会将一个元素赋值给变量

```
                
            const arr = ["孙悟空", "猪八戒", "沙和尚", "唐僧"]

            for(let value of arr){
                console.log(value)
            }

```

#### 数组方法

一些数组的方法：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array

-  **Array.isArray()**

  - 用来检查一个对象是否是数组   

    ```
               console.log(Array.isArray({ name: "孙悟空" })) // false
               console.log(Array.isArray([1, 2, 3])) // true
    ```

- **at()**

  - 可以根据索引获取数组中的指定元素

  -  at可以接收负索引作为参数

    ```
                const arr = ["孙悟空", "猪八戒", "沙和尚", "唐僧"]
    
                console.log(arr.at(-2)) //沙和尚
    ```

- **concat()**

  - 用来连接两个或多个数组

  - 非破坏性方法，不会影响原数组，而是返回一个新的数组

    ```
    const arr = ["孙悟空", "猪八戒", "沙和尚", "唐僧"]
    
    const arr2 = ["白骨精", "蜘蛛精", "玉兔精"]
    
    let result = arr.concat(arr2, ["牛魔王","铁扇公主"])
    
    console.log(result)//"孙悟空", "猪八戒", "沙和尚", "唐僧","白骨精", "蜘蛛精", "玉兔精","牛魔王","铁扇公主"
    ```

- **indexOf()**
  
  - 获取元素在数组中第一次出现的索引
    - 参数：
      -  要查询的元素
      - 查询的起始位置

```
let arr = ["孙悟空", "猪八戒", "沙和尚", "唐僧", "沙和尚"]
  let result = arr.indexOf("沙和尚"，3)
   console.log(result)//4
```

- **lastIndexOf()**

  - 获取元素在数组中最后一次出现的位置
  - 返回值：
    - 找到了则返回元素的索引，
    - 没有找到返回-1

  ```
  let arr = ["孙悟空", "猪八戒", "沙和尚", "唐僧", "沙和尚"]
  result = arr.lastIndexOf("沙和尚", 3)
  result = arr.indexOf("白骨精")
  console.log(result)//4  -1
  ```

- **join()**
  
  - 将一个数组中的元素连接为一个字符串
  - ["孙悟空", "猪八戒", "沙和尚", "唐僧", "沙和尚"] -> "孙悟空,猪八戒,沙和尚,唐僧,沙和尚"
  - 参数：
    - 指定一个字符串作为连接符

```
result = arr.join()
result = arr.join("@-@")//连接符
result = arr.join("")
```

- **slice()**
  - 用来截取数组（非破坏性方法）
  - 参数：
    - 截取的起始位置（包括该位置）
    - 截取的结束位置（不包括该位置） 
      - 第二个参数可以省略不写，如果省略则会一直截取到最后
      - 索引可以是负值

```
            arr = ["孙悟空", "猪八戒", "沙和尚", "唐僧"]
            result = arr.slice(0, 2)
            result = arr.slice(1, 3)
            result = arr.slice(1, -1)
            
            result = arr.slice()//浅拷贝
```

如果将两个参数全都省略，则可以对数组进行浅拷贝（浅复制）

### 对象的复制

- 如何去复制一个对象 复制必须要产生新的对象
- 当调用slice时，会产生一个新的数组对象，从而完成对数组的复制

```
       const arr = ["孙悟空", "猪八戒", "沙和尚"]

       const arr2 = arr  // 是赋值，两个元素指向同一个对象，不是复制
       
        // 如何去复制一个对象 复制必须要产生新的对象
        // 当调用slice时，会产生一个新的数组对象，从而完成对数组的复制
        const arr3 = arr.slice()
```

### 深拷贝与浅拷贝

####   浅拷贝（shallow copy）

- 通常对对象的拷贝都是浅拷贝

- 浅拷贝顾名思义，只对对象的浅层进行复制（只复制一层）

-  如果对象中存储的数据是原始值，那么拷贝的深浅是不重要

- 浅拷贝只会对对象本身进行复制，不会复制对象中的属性（或元素）

  ```
          const arr2 = arr.slice() // 浅拷贝
  ```

####  深拷贝（deep copy）

- 深拷贝指不仅复制对象本身，还复制对象中的属性和元素

- 因为性能问题，通常情况不太使用深拷贝

  ```
    const arr3 = structuredClone(arr) // 专门用来深拷贝的方法
  ```

**区别：**浅拷贝，数组中的元素指向的还是原来的对象。深拷贝，相当于把元素又重新new一份，内存地址变了

### 对象的复制（展开运算符）

**.. (展开运算符)**

- 可以将一个数组中的元素展开到另一个数组中或者作为函数的参数传递

  ```
  const arr4 = [10, 20, 30]
  
  function sum(a, b, c) {
       return a + b + c
  }
              
  let result = sum(...arr4)
  ```

  

- 通过它也可以对数组进行浅复制

**对象的复制**

- Object.assign(目标对象, 被复制的对象，把后面对象的属性赋值到前面对象上)

  ```
  const obj = { name: "孙悟空", age: 18 }
  const obj2 = Object.assign({}, obj)
  ```

- 将被复制对象中的属性复制到目标对象里，并将目标对象返回

​    也可以使用展开运算符对对象进行复制

```
const obj3 = { address: "高老庄", ...obj, age: 48 } // 将obj中的属性在新对象中展开
```

### 数组的方法（增删）

#### **push()**

- 向数组的末尾添加一个或多个元素，并返回新的长度

  ```
   let arr = ["孙悟空", "猪八戒", "沙和尚"]
  let result = arr.push("唐僧", "白骨精")
  console.log(result)//5
  ```

####  pop()

- 删除并返回数组的最后一个元素

  ```
   let arr = ["孙悟空", "猪八戒", "沙和尚","白骨精"]
   result = arr.pop()
   console.log(result)//"白骨精"
  ```

####  unshift()

- 向数组的开头添加一个或多个元素，并返回新的长度

  ```
   arr.unshift("牛魔王")
  ```

####  shift()

- 删除并返回数组的第一个元素

  ```
  arr.shift()
  ```

#### splice()

- 可以删除、插入、替换数组中的元素

- 参数：

  - 删除的起始位置

    ```
     result = arr.splice(1)
    ```

  - 删除的数量

    ```
     result = arr.splice(1, 3)
    ```

  - 要插入的元素

    ```
     result = arr.splice(1, 0, "牛魔王", "铁扇公主", "红孩儿")
    ```

- 返回值：

  - 返回被删除的元素

####  reverse()

反转数组

```
 arr = ["a", "b", "c", "d"]
 arr.reverse()
 console.log(arr)//"d","c", "b","a"
```

### 数组去重

```
            const arr = [1, 2, 1, 3, 2, 2, 4, 5, 5, 6, 7]

            // 编写代码去除数组中重复的元素

            // 分别获取数组中的元素
            for (let i = 0; i < arr.length; i++) {
                // 获取当前值后边的所有值
                for (let j = i + 1; j < arr.length; j++) {
                    // 判断两个数是否相等
                    if (arr[i] === arr[j]) {
                        // 出现了重复元素，删除后边的元素
                        arr.splice(j, 1)

                        /* 
                            当arr[i] 和 arr[j]相同时，它会自动的删除j位置的元素，然后j+1位置的元素，会变成j位置的元素
                            而j位置已经比较过了，不会重复比较，所以会出现漏比较的情况

                            解决办法，当删除一个元素后，需要将该位置的元素在比较一遍
                        */
                        j--
                    }
                }
            }
```

```
        const arr = [1, 2, 1, 3, 2, 2, 4, 5, 5, 6, 7]

        // 获取数组中的元素
        // for(let i=0; i<arr.length; i++){
        //     const index = arr.indexOf(arr[i], i+1)
        //     if(index !== -1){
        //         // 出现重复内容
        //         arr.splice(index, 1)
        //         i--
        //     }
        // }
        // console.log(arr)

        const newArr = []

        for(let ele of arr){
            if(newArr.indexOf(ele) === -1){
                newArr.push(ele)
            }
        }

        console.log(newArr)
```

### 数组排序

```
            /* 
                 [9,1,3,2,8,0,5,7,6,4]

                 思路一：
                    9, 1, 3, 2, 8, 0, 5, 7, 6, 4
                    - 比较相邻的两个元素，然后根据大小来决定是否交换它们的位置
                    - 例子：
                        第一次排序：1, 3, 2, 8, 0, 5, 7, 6, 4, 9
                        第二次排序：1, 2, 3, 0, 5, 7, 6, 4, 8, 9
                        第三次排序：1, 2, 0, 3, 5, 6, 4, 7, 8, 9
                        ...
                        倒数第二次 0, 1, 2, 3, 4, 5, 6, 7, 8, 9

                    - 这种排序方式，被称为冒泡排序，冒泡排序是最慢的排序方式，
                        数字少还可以凑合用，不适用于数据量较大的排序

                思路2：
                    9, 1, 3, 2, 8, 0, 5, 7, 6, 4
                    - 取出一个元素，然后将其他元素和该元素进行比较，如果其他元素比该元素小则交换两个元素的位置
                    - 例子：
                        0, 9, 3, 2, 8, 1, 5, 7, 6, 4
                        0, 1, 9, 3, 8, 2, 5, 7, 6, 4
                        0, 1, 2, 9, 8, 3, 5, 7, 6, 4
                        ...

                    - 选择排序

            */

            const arr = [9, 1, 3, 2, 8, 0, 5, 7, 6, 4]
            for (let j = 0; j < arr.length - 1; j++) {
                for (let i = 0; i < arr.length - 1; i++) {
                    // arr[i] 前边的元素 arr[i+1] 后边元素
                    if (arr[i] < arr[i + 1]) {
                        // 大数在前，小数在后，需要交换两个元素的位置
                        let temp = arr[i] // 临时变量用来存储arr[i]的值
                        arr[i] = arr[i + 1] // 将arr[i+1]的值赋给arr[i]
                        arr[i + 1] = temp // 修改arr[i+1]的值
                    }
                }
            }
```

```

            /* 
                1, 3, 2, 8, 0, 5, 7, 6, 4, 9
                1, 2, 3, 0, 5, 7, 6, 4, 8, 9
                1, 2, 0, 3, 5, 6, 4, 7, 8, 9
                1, 0, 2, 3, 5, 4, 6, 7, 8, 9
            */

            const arr = [9, 1, 3, 2, 8, 0, 5, 7, 6, 4]
            // for (let j = 0; j < arr.length - 1; j++) {
            //     for (let i = 0; i < arr.length - 1 - j; i++) {
            //         if (arr[i] > arr[i + 1]) {
            //             let temp = arr[i] 
            //             arr[i] = arr[i + 1]
            //             arr[i + 1] = temp
            //         }
            //     }

            //     console.log(arr)

            // }

            // console.log(arr)

            /* 
                选择排序
                    - 取出一个元素，然后将其他元素和该元素进行比较，如果其他元素比该元素小则交换两个元素的位置
            */

            console.log(arr)

            for(let i=0; i<arr.length; i++){
                for(let j=i+1; j<arr.length; j++){
                    if(arr[i] > arr[j]){
                        // 交换两个元素的位置
                        let temp = arr[i]
                        arr[i] = arr[j]
                        arr[j] = temp
                    }
                }

            }

            console.log(arr)
```

### 函数

```
            const arr = [9, 1, 3, 2, 8, 0, 5, 7, 6, 4]
            const arr2 = [9, 8, 7, 6, 5, 4, 3, 2, 1]

            function sort(array) {
                const arr = [...array]
                for (let i = 0; i < arr.length; i++) {
                    for (let j = i + 1; j < arr.length; j++) {
                        if (arr[i] > arr[j]) {
                            // 交换两个元素的位置
                            let temp = arr[i]
                            arr[i] = arr[j]
                            arr[j] = temp
                        }
                    }
                }
                return arr
            }

            let result = sort(arr2)

            // console.log(arr2)
            // console.log(result)

            class Person {
                constructor(name, age) {
                    this.name = name
                    this.age = age
                }
            }

            const personArr = [
                new Person("孙悟空", 18),
                new Person("沙和尚", 38),
                new Person("红孩儿", 8),
                new Person("白骨精", 16),
            ]


            // filter()函数用来对数组进行过滤
            function filter(arr) {

                const newArr = []

                for (let i = 0; i < arr.length; i++) {
                    if (arr[i].age < 18) {
                        newArr.push(arr[i])
                    }
                }

                return newArr
            }

            result = filter(personArr)
            console.log(result)
```

```
            class Person {
                constructor(name, age) {
                    this.name = name
                    this.age = age
                }
            }

            const personArr = [
                new Person("孙悟空", 18),
                new Person("沙和尚", 38),
                new Person("红孩儿", 8),
                new Person("白骨精", 16),
            ]

            // filter()函数用来对数组进行过滤
            /* 
                目前我们的函数只能过滤出数组中age属性小于18的对象，
                    我们希望过滤更加灵活：
                        比如：过滤数组中age大于18的对象
                                     age大于60的对象
                                     age大于n的对象
                             过滤数组中name为xxx的对象
                             过滤数组中的偶数
                             ...


                一个函数的参数也可以是函数，
                    如果将函数作为参数传递，那么我们就称这个函数为回调函数（callback）
            
            */
            function filter(arr, cb) {
                const newArr = []

                // console.log("-->", cb)
                // cb()

                for (let i = 0; i < arr.length; i++) {
                    // arr[i].age >= 18
                    // arr[i].age > 60
                    // arr[i].age > n
                    // arr[i].name === "xxx"
                    // arr[i] % 2 === 0
                    if (cb(arr[i])) {
                        newArr.push(arr[i])
                    }
                }

                return newArr
            }

            function fn(a){
                return a.name === "孙悟空"
            }

            result = filter(personArr, fn)
            console.log(result)
```

### 高阶函数

- 如果一个函数的参数或返回值是函数，则这个函数就称为高阶函数
-   为什么要将函数作为参数传递？（回调函数有什么作用？）
-   将函数作为参数，意味着可以对另一个函数动态的传递代码

### 闭包      

闭包就是能访问到外部函数作用域中变量的函数

**什么时候使用：**当我们需要隐藏一些不希望被别人访问的内容时就可以使用闭包

**构成闭包的要件：**

1. 函数的嵌套

2. 内部函数要引用外部函数中的变量

3. 内部函数要作为返回值返回

```
            function outer(){
                let num = 0 // 位于函数作用域中

                return () => {
                    num++
                    console.log(num)
                }
            }

            const newFn = outer()

            // console.log(newFn)
            newFn()
            newFn()
            newFn()
```

**闭包的生命周期：**

- 闭包在外部函数调用时产生，外部函数每次调用都会产生一个全新的闭包
- 在内部函数丢失时销毁（内部函数被垃圾回收了，闭包才会消失）

**注意事项：**

- 闭包主要用来隐藏一些不希望被外部访问的内容，这就意味着闭包需要占用一定的内存空间

- 相较于类来说，闭包比较浪费内存空间（类可以使用原型而闭包不能），需要执行次数较少时，使用闭包，需要大量创建实例时，使用类

### 递归

- 调用自身的函数称为递归函数
- 递归的作用和循环是基本一直

**编写递归函数，一定要包含两个要件：**

- 基线条件 ——  递归的终止条件
- 递归条件 ——  如何对问题进行拆分

**注意：**递归的作用和循环是一致的，不同点在于，递归思路的比较清晰简洁，循环的执行性能比较好，在开发中，一般的问题都可以通过循环解决，也是尽量去使用循环，少用递归，只在一些使用循环解决比较麻烦的场景下，才使用递归

### 数组的方法

#### sort()

- sort用来对数组进行排序（会对改变原数组）
-  sort默认会将数组升序排列

**注意：**sort默认会按照Unicode编码进行排序，所以如果直接通过sort对数字进行排序可能会得到一个不正确的结果

**参数：**可以传递一个回调函数作为参数，通过回调函数来指定排序规则

- (a, b) => a - b 升序排列

- (a, b) => b - a 降序排列

  ```
  arr.sort((a, b) => a - b)
  arr.sort((a, b) => b - a)
  ```

#### forEach()

- 用来遍历数组
- 它需要一个回调函数作为参数，这个回调函数会被调用多次，数组中有几个元素，回调函数就会调用几次，每次调用，都会将数组中的数据作为参数传递

- 回调函数中有三个参数：
  - element 当前的元素
  - index 当前元素的索引
  - array 被遍历的数组

```
arr.forEach((element, index, array) => {
  console.log(array)
})

arr.forEach((element, index) => console.log(index, element))
```

#### filter()

- 将数组中符合条件的元素保存到一个新数组中返回
- 需要一个回调函数作为参数，会为每一个元素去调用回调函数，并根据返回值来决定是否将元素添加到新数组中
- 非破坏性方法，不会影响原数组

```
let result = arr.filter((ele) => ele > 5)
```

####  map()

- 根据当前数组生成一个新数组
- 需要一个回调函数作为参数，回调函数的返回值会成为新数组中的元素
- 非破坏性方法不会影响原数组

```
result = arr.map((ele) => ele * 2)
```

#### reduce()

- 可以用来将一个数组中的所有元素整合为一个值
- 参数：
  - 回调函数，通过回调函数来指定合并的规则
  -  可选参数，初始值

```
result = arr.reduce((a, b) => {
                /* 
                    1, 2
                    3, 3
                    6, 4
                    10, 5
                
                */
                // console.log(a, b)

                return a * b
            })
```

### 可变参数

#### arguments

- arguments是函数中又一个隐含参数
- arguments是一个类数组对象（伪数组） 和数组相似，可以通过索引来读取元素，也可以通过for循环变量，但是它不是一个数组对象，不能调用数组的方法
- arguments用来存储函数的实参，无论用户是否定义形参，实参都会存储到arguments对象中可以通过该对象直接访问实参

#### 可变参数，在定义函数时可以将参数指定为可变参数

- 可变参数可以接收任意数量实参，并将他们统一存储到一个数组中返回
- 可变参数的作用和arguments基本是一致，但是也具有一些不同点：
  - 可变参数的名字可以自己指定
  - 可变参数就是一个数组，可以直接使用数组的方法
  - 可变参数可以配合其他参数一起使用

### 函数

**根据函数调用方式的不同，this的值也不同：**

- 以函数形式调用，this是window
- 以方法形式调用，this是调用方法的对象
- 构造函数中，this是新建的对象
- 箭头函数没有自己的this，由外层作用域决定
- 通过call和apply调用的函数，它们的第一个参数就是函数的this
- 通过bind返回的函数，this由bind第一个参数决定（无法修改）

**调用函数除了通过 函数() 这种形式外，还可以通过其他的方式来调用函数**

**比如，我们可以通过调用函数的call()和apply()来个方法来调用函数**

- **函数.call()**
- **函数.apply()**

-  call 和 apply除了可以调用函数，还可以用来指定函数中的this
- call和apply的第一个参数，将会成为函数的this
- 通过call方法调用函数，函数的实参直接在第一个参数后一个一个的列出来
- 通过apply方法调用函数，函数的实参需要通过一个数组传递

**bind() 是函数的方法，可以用来创建一个新的函数**

- bind可以为新函数绑定this
- bind可以为新函数绑定参数

箭头函数没有自身的this，它的this由外层作用域决定，也无法通过call apply 和 bind修改它的this ，箭头函数中没有arguments

###  解构赋值

```
           /*
                解构赋值
             */

            const arr = ["孙悟空", "猪八戒", "沙和尚"]

            let a,
                b,
                c

                // a = arr[0]
                // b = arr[1]
                // c = arr[2]
            ;[a, b, c] = arr // 解构赋值

            let [d, e, f, g] = ["唐僧", "白骨精", "蜘蛛精", "玉兔精"] // 声明同时解构

            console.log(d, e, f, g)
            // ;[d, e, f, g] = [1, 2, 3]
            // ;[d, e, f = 77, g = 10] = [1, 2, 3]
            ;[d, e, f = 77, g = g] = [1, 2, 3]

            let [n1, n2, ...n3] = [4, 5, 6, 7] // 解构数组时，可以使用...来设置获取多余的元素

            // console.log(n1, n2, n3)


            function fn(){
                return ["二郎神", "猪八戒"]
            }

            let [name1, name2] = fn()

            // 可以通过解构赋值来快速交换两个变量的值
            let a1 = 10
            let a2 = 20

            // let temp = a1
            // a1 = a2
            // a2 = temp

            ;[a1, a2] = [a2, a1] // [20, 10]

            const arr2 = ["孙悟空", "猪八戒"]
            // console.log(arr2)

            ;[arr2[0], arr2[1]] = [arr2[1], arr2[0]]
            // console.log(arr2)


            // console.log("a1 =", a1)
            // console.log("a2 =", a2)


            /* 
                数组中可以存储任意类型的数据，也可以存数组,
                    如果一个数组中的元素还是数组，则这个数组我们就称为是二维数组
            */

            const arr3 = [["孙悟空", 18, "男"], ["猪八戒" ,28, "男"]]

            // for(let stu of arr3){
            //     for(let v of stu){
            //         console.log(v)
            //     }
            // }
```

#### 对象的结构赋值

```
            const obj = { name: "孙悟空", age: 18, gender: "男" }

            // let { name, age, gender } = obj // 声明变量同时解构对象

            let name, age, gender

            ;({ name, age, gender } = obj)

            let { address } = obj // 没有的属性返回undefined

            // console.log(name, age, gender)

            let {name:a, age:b, gender:c, address:d="花果山"} = obj

            console.log(a, b, c, d)
```

### 对象的序列化

#### 对象的序列化

-  JS中的对象使用时都是存在于计算机的内存中的
- 序列化指将对象转换为一个可以存储的格式， 在JS中对象的序列化通常是将一个对象转换为字符串（JSON字符串）
- 序列化的用途（对象转换为字符串有什么用）：
  - 对象转换为字符串后，可以将字符串在不同的语言之间进行传递
  - 甚至人可以直接对字符串进行读写操作，使得JS对象可以不同的语言之间传递
  - 用途：
    - 作为数据交换的格式
    - 用来编写配置文字

- 如何进行序列化：

  - 在JS中有一个工具类 JSON （JavaScript Object Notation） JS对象表示法

  - JS对象序列化后会转换为一个字符串，这个字符串我们称其为JSON字符串  

- 也可以手动的编写JSON字符串，在很多程序的配置文件就是使用JSON编写的
- 编写JSON的注意事项：
- JSON字符串有两种类型：
  - JSON对象 {}
  - JSON数组 []
- JSON字符串的属性名必须使用双引号引起来
- JSON中可以使用的属性值（元素）
  - 数字（Number）
  - 字符串（String） 必须使用双引号
  - 布尔值（Boolean）
  - 空值（Null）
  - 对象（Object {}）
  - 数组（Array []）
- JSON的格式和JS对象的格式基本上一致的，

 **注意：**JSON字符串如果属性是最后一个，则不要再加

```
            const obj = {
                name: "孙悟空",
                age: 18,
            }

            // 将obj转换为JSON字符串
            const str = JSON.stringify(obj) //JSON.stringify() 可以将一个对象转换为JSON字符串

            const obj2 = JSON.parse(str) // JSON.parse() 可以将一个JSON格式的字符串转换为JS对象
```

###  Map

- Map用来存储键值对结构的数据（key-value）
- Map用来处理数据
- Object中存储的数据就可以认为是一种键值对结构
- Map和Object的主要区别：
  - Object中的属性名只能是字符串或符号，如果传递了一个其他类型的属性名， JS解释器会自动将其转换为字符串
  - Map中任何类型的值都可以称为数据的key

   **创建：**new Map()

**属性和方法：**

- map.size() 获取map中键值对的数量
- map.set(key, value) 向map中添加键值对
- map.get(key) 根据key获取值  
- map.delete(key) 删除指定数据
- map.has(key) 检查map中是否包含指定键
- map.clear() 删除全部的键值对

```

            const map = new Map()

            map.set("name", "孙悟空")
            map.set("age", 18)
            map.set({}, "呵呵")

            // 将map转换为数组
            // const arr = Array.from(map) // [["name","孙悟空"],["age",18]]
            // const arr = [...map]

            // console.log(arr)

            const map2 = new Map([
                ["name", "猪八戒"],
                ["age", 18],
                [{}, () => {}],
            ])

            // console.log(map2)

            // 遍历map
            // for (const [key, value] of map) {
            //     // const [key, value] = entry
            //     console.log(key, value)
            // }

            // map.forEach((key, value)=>{
            //     console.log(key, value)
            // })
            
            /* 
                map.keys() - 获取map的所有的key
                map.values() - 获取map的所有的value
            */

            for(const key of map.keys()){
                console.log(key)
            }
```





### Set

####         Set

- Set用来创建一个集合
- 它的功能和数组类似，不同点在于Set中不能存储重复的数据

**使用方式：**

​          **创建**

​            \- new Set()

​            \- new Set([...])

​          **方法**

​            size 获取数量

​            add() 添加元素

​            has() 检查元素

​            delete() 删除元素

```
       // 创建一个Set
            const set = new Set()

            // 向set中添加数据
            set.add(10)
            set.add("孙悟空")
            set.add(10)

            // console.log(set)

            // for(const item of set){
            //     console.log(item)
            // }

            const arr = [...set]

            // console.log(arr)

            const arr2 = [1,2,3,2,1,3,4,5,4,6,7,7,8,9,10]

            const set2 = new Set(arr2)

            console.log([...set2])
```

###  Math

- Math一个工具类

- Math中为我们提供了数学运算相关的一些常量和方法

- 常量：

  - Math.PI 圆周率

- 方法：

  - Math.abs() 求一个数的绝对值

  - Math.min() 求多个值中的最小值

  - Math.max() 求多个值中的最大值

  - Math.pow() 求x的y次幂

  - Math.sqrt() 求一个数的平方根

  - Math.floor() 向下取整

  - Math.ceil() 向上取整

  - Math.round() 四舍五入取整

  - Math.trunc() 直接去除小数位

  - Math.random() 生成一个0-1之间的随机数

### Date（时间获取）

在JS中所有的和时间相关的数据都由Date对象来表示

**对象的方法：**

- getFullYear() 获取4位年份
- getMonth() 返当前日期的月份（0-11）
- getDate() 返回当前是几日
- getDay() 返回当前日期是周几（0-6） 0表示周日
- getTime() 返回当前日期对象的时间戳
  - 时间戳：自1970年1月1日0时0分0秒到当前时间所经历的毫秒数
  -  计算机底层存储时间时，使用都是时间戳
- Date.now() 获取当前的时间戳

```
            let d = new Date() // 直接通过new Date()创建时间对象时，它创建的是当前的时间的对象

            // 可以在Date()的构造函数中，传递一个表示时间的字符串
            // 字符串的格式：月/日/年 时:分:秒
            // 年-月-日T时:分:秒
            d = new Date("2019-12-23T23:34:35")


            // new Date(年份, 月, 日, 时, 分, 秒, 毫秒)
            d = new Date(2016, 0, 1, 13, 45, 33)
```

### 日期的格式化

```
const d = new Date()

let result = d.toLocaleDateString() // 将日期转换为本地的字符串
result = d.toLocaleTimeString() // 将时间转换为本地的字符串
```

#### **toLocaleString()**

- 可以将一个日期转换为本地时间格式的字符串

**参数：**

- 描述语言和国家信息的字符串
  -  zh-CN 中文中国
  - zh-HK 中文香港
  - en-US 英文美国

需要一个对象作为参数，在对象中可以通过对象的属性来对日期的格式进行配置

- dateStyle 日期的风格
- timeStyle 时间的风格
  -  full
  - long
  - medium
  - short

- hour12 是否采用12小时值
  -  true
  - false

- weekday 星期的显示方式
  - long 
  - short
  - narrow

-  year
  - numeric
  - 2-digit

### 包装类

在JS中，除了直接创建原始值外，也可以创建原始值的对象

- 通过 new String() 可以创建String类型的对象
- 通过 new Number() 可以创建Number类型的对象
- 通过 new Boolean() 可以创建Boolean类型的对象

**注意：**但是千万不要这么做

#### 包装类：

JS中一共有5个包装类

- String --> 字符串包装为String对象
- Number --> 数值包装为Number对象
- Boolean --> 布尔值包装为Boolean对象
- BigInt --> 大整数包装为BigInt对象
- Symbol --> 符号包装为Symbol对象

通过包装类可以将一个原始值包装为一个对象， 当我们对一个原始值调用方法或属性时，JS解释器会临时将原始值包装为对应的对象，然后调用这个对象的属性或方法。

由于原始值会被临时转换为对应的对象，这就意味着对象中的方法都可以直接通过原始值来调用

### 字符串的方法

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String

####  字符串：

- 字符串其本质就是一个字符数组

- "hello" --> ["h", "e", "l", "l", "o"]

- 字符串的很多方法都和数组是非常类似的

- 属性和方法：

  -  length 获取字符串的长度
  - 字符串[索引] 获取指定位置的字符
  -  str.at() （实验方法）\- 根据索引获取字符，可以接受负索引

  -  str.charAt()- 根据索引获取字符

  -  str.concat()- 用来连接两个或多个字符串

  -  str.includes()- 用来检查字符串中是否包含某个内容，有返回true，没有返回false

  -  str.indexOf()

  - str.lastIndexOf()- 查询字符串中是否包含某个内容

  -  str.startsWith()- 检查一个字符串是否以指定内容开头

  - str.endsWith()- 检查一个字符串是否以指定内容结尾

  -  str.padStart()

  - str.padEnd()- 通过添加指定的内容，使字符串保持某个长度

  -  str.replace()- 使用一个新字符串替换一个指定内容

  - str.replaceAll()   - 使用一个新字符串替换所有指定内容

  -  str.slice()- 对字符串进行切片

  - str.substring()- 截取字符串

  - str.split()- 用来将一个字符串拆分为一个数组

  - str.toLowerCase() - 将字符串转换为小写

  - str.toUpperCase() - 将字符串转换为大写

  - str.trim() - 去除前后空格

  - str.trimStart()- 去除开始空格

  - str.trimEnd() - 去除结束空格

### 正则表达式

- 正则表达式用来定义一个规则
- 通过这个规则计算机可以检查一个字符串是否符合规则或者将字符串中符合规则的内容提取出来
- 正则表达式也是JS中的一个对象，所以要使用正则表达式，需要先创建正则表达式的对象

```
                1.在正则表达式中大部分字符都可以直接写
                2.| 在正则表达式中表示或
                3.[] 表示或（字符集）
                    [a-z] 任意的小写字母
                    [A-Z] 任意的大写字母
                    [a-zA-Z] 任意的字母
                    [0-9]任意数字
                4.[^] 表示除了
                    [^x] 除了x
                5. . 表示除了换行外的任意字符
                6. 在正则表达式中使用\作为转义字符
                7. 其他的字符集
                    \w 任意的单词字符 [A-Za-z0-9_]
                    \W 除了单词字符 [^A-Za-z0-9_]
                    \d 任意数字 [0-9]
                    \D 除了数字 [^0-9]
                    \s 空格
                    \S 除了空格
                    \b 单词边界
                    \B 除了单词边界
                8. 开头和结尾
                    ^ 表示字符串的开头
                    $ 表示字符串的结尾
            */ 

            let re = /abc|bcd/

            re = /[a-z]/

            re = /[A-Z]/

            re = /[A-Za-z]/

            re = /[a-z]/i // 匹配模式i表示忽略大小写

            re = /[^a-z]/ // 匹配包含小写字母以外内容的字符串

            re = /./

            re = /\./

            re = /\w/

            re = /^a/ // 匹配开始位置的a

            re = /a$/ // 匹配结束位置的a

            re = /^a$/ // 只匹配字母a，完全匹配，要求字符串必须和正则完全一致

            re = /^abc$/

```

```
             量词
                    {m} 正好m个
                    {m,} 至少m个
                    {m,n} m-n个
                    + 一个以上，相当于{1,}
                    * 任意数量的a
                    ? 0-1次 {0,1}
```

 **re.exec()**

​          \- 获取字符串中符合正则表达式的内容

### 字符串

- split()- 可以根据正则表达式来对一个字符串进行拆分
- search()- 可以去搜索符合正则表达式的内容第一次在字符串中出现的位置
- replace()- 根据正则表达式替换字符串中的指定内容
- match() - 根据正则表达式去匹配字符串中符合要求的内容
- matchAll()- 根据正则表达式去匹配字符串中符合要求的内容(必须设置g 全局匹配)- 它返回的是一个迭代器

### 垃圾回收

**垃圾回收（Garbage collection）**

- 和生活一样，生活时间长了以后会产生生活垃圾，程序运行一段时间后也会产生垃圾

- 在程序的世界中，什么是垃圾？

  - 如果一个对象没有任何的变量对其进行引用，那么这个对象就是一个垃圾

  - 垃圾对象的存在，会严重的影响程序的性能

  - 在JS中有自动的垃圾回收机制，这些垃圾对象会被解释器自动回收，我们无需手动处理

  - 对于垃圾回收来说，我们唯一能做的事情就是将不再使用的变量设置为null